package com.citi.gpae.scheduler.controllers;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/scheduler")
@Slf4j
public class RealmKeyController {

    private final JobScheduleRepository jobScheduleRepository;
    private final RealmKeyService realmKeyService; // business logic

    @GetMapping("/refreshOAuthKey")
    public ResponseEntity<String> refreshOAuthKey() {
        JobSchedule jobSchedule =
                jobScheduleRepository.findByJobName(JobNameEnum.OAUTH_PUBLIC_KEY_REFRESH);

        if (!jobSchedule.isActive()) {
            return new ResponseEntity<>("Job is inactive", HttpStatus.METHOD_NOT_ALLOWED);
        }

        log.info("üîÑ Autosys-triggered OAuth Key Refresh job triggered");
        
        realmKeyService.refreshKey(jobSchedule);

        return new ResponseEntity<>("OK", HttpStatus.OK);
    }
}
----------------------------
@Service
@RequiredArgsConstructor
@Slf4j
public class RealmKeyService {

    private final TokenValidationService tokenValidationService;
    private final RealmPublicKeyRefresher refresher;

    public void refreshKey(JobSchedule jobSchedule) {
        log.info("üîë Starting OAuth public key refresh job: {}", jobSchedule.getJobName());

        try {
            String newKey = refresher.fetchPublicKey();
            tokenValidationService.updateKey(newKey);

            log.info("‚úÖ OAuth public key successfully refreshed");
        } catch (Exception e) {
            log.error("‚ùå OAuth key refresh failed", e);
        }
    }
}
--------------------------------
@Service
@Getter
@Setter
@Slf4j
public class RealmKeyJob implements Runnable {

    private JobSchedule jobSchedule;
    private RealmKeyService realmKeyService;

    @Override
    public void run() {
        log.info("Running job: {}", jobSchedule.getJobName());
        realmKeyService.refreshKey(jobSchedule);
    }
}
