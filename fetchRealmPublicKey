@Service
@RequiredArgsConstructor
@Slf4j
public class RealmPublicKeyRefresher {

    private final OAuthProps props;
    private final TokenValidationService tokenValidationService;
    private final RestTemplate restTemplate = new RestTemplate();

    public void refreshKey() {
        try {
            String url = "https://" + props.baseUrl() + "/oauth/token_key";

            HttpHeaders headers = new HttpHeaders();
            headers.setBasicAuth(props.clientId(), props.secret());
            HttpEntity<Void> request = new HttpEntity<>(headers);

            ResponseEntity<Map> response = restTemplate.exchange(url, HttpMethod.GET, request, Map.class);

            String pemKey = (String) response.getBody().get("value");  // PEM format

            // Remove header/footer and new lines
            String cleanKey = pemKey
                    .replace("-----BEGIN PUBLIC KEY-----", "")
                    .replace("-----END PUBLIC KEY-----", "")
                    .replaceAll("\\s+", "");

            tokenValidationService.updatePublicKey(cleanKey);

            log.info("‚úÖ Realm public key refreshed successfully");

        } catch (Exception e) {
            log.error("‚ùå Failed to refresh realmPublicKey: {}", e.getMessage());
        }
    }
}
-------------------
@Component
@RequiredArgsConstructor
@Slf4j
public class TokenValidationService {

    private final OAuthProps oAuthProps;
    private volatile RSAPublicKey pubKey;

    @PostConstruct
    public void init() {
        updatePublicKey(oAuthProps.realmPublicKey());
    }

    public void updatePublicKey(String base64Key) {
        try {
            X509EncodedKeySpec keySpecX509 = new X509EncodedKeySpec(Base64.getDecoder().decode(base64Key));
            this.pubKey = (RSAPublicKey) KeyFactory.getInstance(oAuthProps.realmPublicKeyAlgorithm())
                    .generatePublic(keySpecX509);
        } catch (Exception e) {
            log.error("ERROR updating realmPublicKey: {}", e.getMessage());
        }
    }

    public TokenValidation validateToken(String token) {
        try {
            Claims claims = Jwts.parser()
                    .verifyWith(pubKey)
                    .build()
                    .parseSignedClaims(token)
                    .getPayload();

            return new TokenValidation(true, null,
                    claims.get("user_name", String.class),
                    claims.get("scope", ArrayList.class));

        } catch (JwtException e) {
            log.warn("Token validation failed: {}", e.getMessage());
            return new TokenValidation(false, e.getMessage(), null, null);
        }
    }
}
------------------
@Configuration
@EnableScheduling
@RequiredArgsConstructor
public class RealmKeyScheduler {

    private final RealmPublicKeyRefresher refresher;

    // Refresh every 12 hours
    @Scheduled(cron = "0 0 */12 * * *")
    public void runRefresh() {
        refresher.refreshKey();
    }
}
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@PostConstruct
public void init() {
    try {
        log.info("üîÑ Attempting to fetch latest realm public key from OAuth server...");
        refresher.refreshKey(); // If successful, pubKey is updated
        log.info("‚úÖ Realm public key successfully loaded from OAuth server at startup");
        return; // Exit method since key is successfully loaded
    } catch (Exception e) {
        log.warn("‚ö† Failed to fetch realm public key from OAuth server: {}. Falling back to local key.",
                e.getMessage());
    }

    // Fallback logic executes ONLY if an exception occurred in the try-block
    try {
        X509EncodedKeySpec keySpecX509 =
                new X509EncodedKeySpec(Base64.getDecoder().decode(oAuthProps.realmPublicKey()));

        pubKey = (RSAPublicKey) KeyFactory.getInstance(oAuthProps.realmPublicKeyAlgorithm())
                .generatePublic(keySpecX509);

        log.info("‚úÖ Fallback realmPublicKey successfully loaded from application.properties");

    } catch (InvalidKeySpecException | NoSuchAlgorithmException ex) {
        log.error("‚ùå Failed to load fallback realmPublicKey from application.properties: {}", ex.getMessage());
        // Optionally: fail startup or leave pubKey = null (but failure is safer)
    }
}
---------------------------
@ExtendWith(MockitoExtension.class)
class TokenValidationServiceSuccessTest {

    @Mock
    private OAuthProps oAuthProps;

    @Mock
    private RealmPublicKeyRefresher refresher;

    @InjectMocks
    private TokenValidationService tokenValidationService;

    @Test
    void testInitFetchesKeySuccessfully() {
        // Arrange: refresher.refreshKey() should succeed (do nothing)
        doNothing().when(refresher).refreshKey();

        // Act
        tokenValidationService.init();

        // Assert: pubKey should be updated by refresher
        // refresher calls updatePublicKey(), so we simulate that
        tokenValidationService.updatePublicKey(generateTestKey());

        assertNotNull(tokenValidationService.getPubKey(), "Public key should be loaded");
    }

    // Generates a real RSA key for testing (base64 encoded X509)
    private String generateTestKey() {
        KeyPairGenerator keyGen;
        try {
            keyGen = KeyPairGenerator.getInstance("RSA");
            keyGen.initialize(2048);
            RSAPublicKey publicKey = (RSAPublicKey) keyGen.generateKeyPair().getPublic();
            return Base64.getEncoder().encodeToString(publicKey.getEncoded());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
--------------------------------
@ExtendWith(MockitoExtension.class)
class TokenValidationServiceFallbackTest {

    @Mock
    private OAuthProps oAuthProps;

    @Mock
    private RealmPublicKeyRefresher refresher;

    @InjectMocks
    private TokenValidationService tokenValidationService;

    @Test
    void testInitFallsBackToLocalKeyWhenServerFails() {
        // Arrange
        doThrow(new RuntimeException("Server down")).when(refresher).refreshKey();
        when(oAuthProps.realmPublicKeyAlgorithm()).thenReturn("RSA");

        // Provide fallback key from properties
        String fallbackKey = generateTestKey();
        when(oAuthProps.realmPublicKey()).thenReturn(fallbackKey);

        // Act
        tokenValidationService.init();

        // Assert
        assertNotNull(tokenValidationService.getPubKey(), "Fallback key should be loaded");
    }

    private String generateTestKey() {
        try {
            KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
            keyGen.initialize(2048);
            RSAPublicKey publicKey = (RSAPublicKey) keyGen.generateKeyPair().getPublic();
            return Base64.getEncoder().encodeToString(publicKey.getEncoded());
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
--------------------------------------------
