@Service
@RequiredArgsConstructor
@Slf4j
public class RealmPublicKeyRefresher {

    private final OAuthProps props;
    private final RestTemplate restTemplate = new RestTemplate();

    public String fetchPublicKey() {
        String url = "https://" + props.baseUrl() + "/oauth/token_key";

        log.debug("Calling OAuth server for latest public key: {}", url);

        HttpHeaders headers = new HttpHeaders();
        headers.setBasicAuth(props.clientId(), props.secret());
        HttpEntity<Void> request = new HttpEntity<>(headers);

        ResponseEntity<Map> response =
                restTemplate.exchange(url, HttpMethod.GET, request, Map.class);

        String pem = (String) response.getBody().get("value");

        log.info("‚úÖ Successfully fetched latest public key from OAuth server");

        return pem.replace("-----BEGIN PUBLIC KEY-----", "")
                  .replace("-----END PUBLIC KEY-----", "")
                  .replaceAll("\\s+", "");
    }
}
-------------------------------

@Component
@RequiredArgsConstructor
@Slf4j
public class TokenValidationService {

    private final OAuthProps oAuthProps;
    private final RealmPublicKeyRefresher refresher;
    private volatile RSAPublicKey pubKey; // Active in-memory key

    @PostConstruct
    public void init() {
        log.info("üîÑ Initializing realm public key...");

        try {
            updateKey(refresher.fetchPublicKey());
            log.info("‚úÖ Public key loaded from OAuth server at startup");
            return;
        } catch (Exception e) {
            log.warn("‚ö† OAuth server fetch failed at startup. Falling back to local key. Reason: {}", e.getMessage());
        }

        try {
            updateKey(oAuthProps.realmPublicKey());
            log.info("‚úÖ Fallback public key loaded from application.properties");
        } catch (Exception ex) {
            log.error("‚ùå Critical: Could not load fallback public key. Application may fail to validate tokens.");
        }
    }

    public void updateKey(String base64Key) {
        try {
            X509EncodedKeySpec keySpec =
                    new X509EncodedKeySpec(Base64.getDecoder().decode(base64Key));

            this.pubKey = (RSAPublicKey) KeyFactory.getInstance(oAuthProps.realmPublicKeyAlgorithm())
                    .generatePublic(keySpec);

            log.info("üîë Public key updated in memory");
        } catch (Exception ex) {
            log.error("‚ùå Failed to update public key: {}", ex.getMessage());
        }
    }

    // NOTE: validateToken() remains unchanged in your system.
}
-------------------------------------------
@Configuration
@EnableScheduling
@RequiredArgsConstructor
@Slf4j
public class RealmKeyScheduler {

    private final TokenValidationService tokenValidationService;
    private final RealmPublicKeyRefresher refresher;

    // Refresh every 12 hours
    @Scheduled(cron = "0 0 */12 * * *")
    public void scheduledRefresh() {
        log.info("‚è± Scheduled public key refresh triggered...");
        try {
            tokenValidationService.updateKey(refresher.fetchPublicKey());
            log.info("‚úÖ Public key successfully refreshed by scheduler");
        } catch (Exception e) {
            log.warn("‚ö† Scheduler refresh failed: {}", e.getMessage());
        }
    }
}
------------------------------------------------------------------------------------

‚úÖ JUnit 5 Tests (No Getters Used)
Helper to access private key

private RSAPublicKey extractPubKey(TokenValidationService service) {
    try {
        Field field = TokenValidationService.class.getDeclaredField("pubKey");
        field.setAccessible(true);
        return (RSAPublicKey) field.get(service);
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
----------------------------
Generate test RSA key
private String generateBase64RsaPublicKey() {
    try {
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
        keyGen.initialize(2048);
        return Base64.getEncoder().encodeToString(keyGen.generateKeyPair().getPublic().getEncoded());
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
---------------------------
@ExtendWith(MockitoExtension.class)
class TokenValidationServiceInitSuccessTest {

    @Mock OAuthProps props;
    @Mock RealmPublicKeyRefresher refresher;
    @InjectMocks TokenValidationService service;

    @Test
    void testInit_LoadsKeyFromServer() {
        when(props.realmPublicKeyAlgorithm()).thenReturn("RSA");
        when(refresher.fetchPublicKey()).thenReturn(generateBase64RsaPublicKey());

        service.init();

        assertNotNull(extractPubKey(service), "Public key must be loaded from server at startup");
    }
}
------------------------------------
@ExtendWith(MockitoExtension.class)
class TokenValidationServiceInitFallbackTest {

    @Mock OAuthProps props;
    @Mock RealmPublicKeyRefresher refresher;
    @InjectMocks TokenValidationService service;

    @Test
    void testInit_UsesFallbackKey() {
        when(props.realmPublicKeyAlgorithm()).thenReturn("RSA");
        when(refresher.fetchPublicKey()).thenThrow(new RuntimeException("Server down"));
        when(props.realmPublicKey()).thenReturn(generateBase64RsaPublicKey());

        service.init();

        assertNotNull(extractPubKey(service), "Fallback key must load when server fetch fails");
    }
}

----------------------------
@ExtendWith(MockitoExtension.class)
class SchedulerRefreshTest {

    @Mock OAuthProps props;
    @Mock RealmPublicKeyRefresher refresher;
    @InjectMocks TokenValidationService service;

    @Test
    void testSchedulerRefreshUpdatesKey() {
        when(props.realmPublicKeyAlgorithm()).thenReturn("RSA");
        when(refresher.fetchPublicKey()).thenReturn(generateBase64RsaPublicKey());

        service.updateKey(refresher.fetchPublicKey());

        assertNotNull(extractPubKey(service), "Scheduler refresh should update pubKey");
    }
}
++++++++++++++++++++++++++++++++++++++++++++++++

keytool -importcert -noprompt -alias tpsoauth-cert -file tpsoauth.crt -keystore truststore.p12 -storetype PKCS12 -storepass changeit

keytool -list -v -keystore truststore.p12 -storepass changeit

